---
title: "Vignette_12"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette_12}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Longitudinal Ordinal Data

Longitudinal binomial/ordinal data is more complicated than longitudinal continuous data. 

Continuous data: marginal and conditional model estimates **are** equivalent

Binomial/Ordinal data: marginal and conditional model estimates **are NOT** equivalent

Rather than listen to me go on about this, and butcher it, try Professor of Biostatistics Dimitris Rizopoulos: http://www.drizopoulos.com/courses/EMC/CE08.pdf 

Review and run the code below to better understand the data distribution. 

### TODO: 
1. Add sources to direct reader.  
2. Check other types of drop-out




### Generate Data with MCAR Drop-out


```{r Run1, eval = F}
library(SPR)
library(MASS)
library(polycor)


set.seed(321)
  
  out <- sim_dat_ord(N = 10000, 
                 number.groups = 2 , 
                 number.timepoints = 4, 
                 reg.formula = formula( ~ Time + Group + Time*Group),
                 Beta = 0.5,
                 thresholds = c(0.25, 0.50, 0.75), 
                 corr = 'ar1', 
                 cor.value = 0.4) 

  
  dat <- out$dat
  str(dat)
  
  dat <- dropout(dat = dat, 
                 type_dropout  = c('mcar'), 
                 prop.miss = 0.3)
  

cor(x = dat$Y_comp[dat$Time == 'Time_1'], y = dat$Y_comp[dat$Time == 'Time_2'])
cor(x = dat$Y_comp[dat$Time == 'Time_2'], y = dat$Y_comp[dat$Time == 'Time_3'])
cor(x = dat$Y_comp[dat$Time == 'Time_3'], y = dat$Y_comp[dat$Time == 'Time_4'])

aggregate(Y_comp ~ Group + Time, FUN = function(x) mean(x, na.rm = T), dat = dat, na.action = na.pass)
aggregate(Y_comp ~ Time + Group, FUN = function(x) prop.table(table(x)), dat = dat, na.action = na.pass)


polycor::polychor(x = dat$Y_comp[dat$Time == 'Time_1'], y = dat$Y_comp[dat$Time == 'Time_2'])
#polychor(x = as.factor(dat$Y_comp[dat$Time == 'Time_1']), y = as.factor(dat$Y_comp[dat$Time == 'Time_2']))
polycor::polychor(x = dat$Y_comp[dat$Time == 'Time_2'], y = dat$Y_comp[dat$Time == 'Time_3'])
polycor::polychor(x = dat$Y_comp[dat$Time == 'Time_3'], y = dat$Y_comp[dat$Time == 'Time_4'])



# Ordinal
mod.ord1 <- MASS:::polr(as.factor(Y_comp) ~ Group + Time + Group*Time , data= dat, method = 'probit', Hess = T)
mod.ord2 <- MASS:::polr(as.factor(Y_mcar) ~ Group + Time + Group*Time , data= dat, method = 'probit', Hess = T)

out$Beta
matrix(mod.ord1$coefficients, ncol = 1, dimnames = list(names(mod.ord1$coefficients)))
matrix(mod.ord2$coefficients, ncol = 1, dimnames = list(names(mod.ord2$coefficients)))
out$thresholds
mod.ord1$zeta
mod.ord2$zeta

```

